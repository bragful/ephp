%% PHP PEG
%% Author: Manuel Rubio <manuel@altenwald.com>

php <- document / '' `
    case Node of
        <<>> -> [];
        _ -> Node
    end
`;

document_parse_error <- .+ `
    throw_error(eparse, Index, Input)
`;

document <- (!init_tag .)* code literal_block? /
            (!init_tag .)+ /
            init_tag space? document_parse_error
`
    case Node of
        [TextLeft, [Type, Code, _EndTag], Chunk] ->
            Label = case Type of
                init_tag when Code =:= [] -> [];
                init_tag -> #eval{statements=Code, line=Index};
                init_tag_value -> Code
            end,
            case iolist_to_binary(TextLeft) of
                <<>> -> [];
                FinalText -> [#print_text{text=FinalText, line=Index}]
            end ++
            lists:flatten([Label|Chunk]);
        Text ->
            [#print_text{text=iolist_to_binary(Text), line=Index}]
    end
`;

code <- code_expr / code_normal ~;

code_normal <- init_tag_code space? statements space? `
    [Init,_,Code,_] = Node,
    [Init,Code,end_tag]
`;

code_expr <- init_value space? (ternary / arith_mono / additive / conditions)
             space? (literal_block / end_tag)+
`
    [Init,_,CodeOne,_,End] = Node,
    Code = [ get_print(CodeOne, Index) | End ],
    [Init,Code,end_tag]
`;

%% Tags

init_tag <- init_value / init_common / init_reduced ~;
init_tag_code <- init_common / init_reduced ~;

init_common  <- '<\?php' `init_tag`;
init_reduced <- '<\?'    `init_tag`;
init_value   <- '<\?='   `init_tag_value`;

end_tag      <- '\?>' [\n]?   `end_tag`;

%% Comments

comment_c <- '/*' (!'*/' .)+ '*/' `
    []
`;

comment_cpp <- '//' (!('\n' / end_tag) .)+ '\n'? `
    []
`;

comment_shell <- '#' (!('\n' / end_tag) .)+ '\n'? `
    []
`;

comment <- comment_shell / comment_c / comment_cpp ~;

% Blocks

literal_block <- (end_tag (document / code_expr) init_tag_code) /
                 (end_tag (document / code_expr)) /
                 end_tag
`
    case Node of
        end_tag -> [];
        [_,[],_] -> [];
        [_,[]] -> [];
        [_,Document,_] ->
            lists:flatten(Document);
        [_,Document] ->
            lists:flatten(Document)
    end
`;

code_block_if_simple <- ':' space? statements space? endif ';' `
    [_,_,Statements|_] = Node,
    case Statements of
        {error, Data} -> throw_error(eparse, Index, Data);
        _ -> Statements
    end
`;

code_block_if_else <- ':' space? statements space? `
    [_,_,Statements|_] = Node,
    case Statements of
        {error, Data} -> throw_error(eparse, Index, Data);
        _ -> Statements
    end
`;

code_block_while <- ':' space? statements space? endwhile ';' `
    [_,_,Statements|_] = Node,
    case Statements of
        {error, Data} -> throw_error(eparse, Index, Data);
        _ -> Statements
    end
`;

code_block_foreach <- ':' space? statements space? endforeach ';' `
    [_,_,Statements|_] = Node,
    case Statements of
        {error, Data} -> throw_error(eparse, Index, Data);
        _ -> Statements
    end
`;

code_block_for <- ':' space? statements space? endfor ';' `
    [_,_,Statements|_] = Node,
    case Statements of
        {error, Data} -> throw_error(eparse, Index, Data);
        _ -> Statements
    end
`;

code_block <- '{' space? ((statements space? '}') / error:code_parse_error) `
    [_,_,Statement|_] = Node,
    case Statement of
        {error, Data} -> throw_error(eparse, Index, Data);
        [St|_] -> St
    end
`;

% Class definition

st_class <- (abstract space)? class space key (space extends space key)?
            (space implements space key (',' space? key)*)? space? '{' space?
            class_block space? '}'
`
    [Abstract,_Class,_,ClassName,Ext,Imp,_,_,_,ClassBlock,_,_] = Node,
    Type = case Abstract of
        [] -> normal;
        _ -> abstract
    end,
    Extends = case Ext of
        [] -> undefined;
        [_,_E,_,SuperClass] -> SuperClass
    end,
    Implements = case Imp of
        [] -> [];
        [_,_I,_,ImpH,ImpList] ->
            [ImpH| [ I || [_,_,I] <- ImpList ] ]
    end,
    #class{
        name=ClassName,
        type=Type,
        extends=Extends,
        implements=Implements,
        constants=[ C || #class_const{}=C <- ClassBlock ],
        attrs=[ A || #class_attr{}=A <- ClassBlock ],
        methods=[ M || #class_method{}=M <- ClassBlock ]}
`;

class_block <- (space? (class_constant / class_variable / class_method) space?)* `
    [ C || [_,C,_] <- Node ]
`;

class_constant <- const space key space? '=' space? expression space? ';' `
    [_Const,_,ConstName,_,_,_,Expr|_] = Node,
    #class_const{name=ConstName, value=Expr}
`;

class_variable <- ((public / protected / private) space)? (static space)?
                  var_simple (space? '=' space? expression)? space? ';'
`
    [Ac,St,Var,Ex|_] = Node,
    Access = case Ac of
        [] -> public;
        [A,_] -> A
    end,
    VarName = Var#variable.name,
    Expr = case Ex of
        [] -> undefined;
        [_,_,_,E] -> E
    end,
    Type = case St of
        [] -> normal;
        _ -> static
    end,
    #class_attr{
        access = Access,
        name = VarName,
        type = Type,
        init_value = Expr}
`;

class_method <- (abstract space)? ((public / protected / private) space)?
                (static space)? st_function
`
    [Abstract,Ac,Static,Fun] = Node,
    Access = case Ac of
        [] -> public;
        [A,_] -> A
    end,
    Type = case {Static,Abstract} of
        {[],[]} -> normal;
        {_,[]} -> static;
        {[],_} -> abstract;
        _ -> throw_error(emethodtypes, Index, Input)
    end,
    #class_method{
        name = Fun#function.name,
        args = Fun#function.args,
        code = Fun#function.code,
        type = Type,
        access = Access}
`;

% Statements

statements <- (!ends (comment / statement / literal_block)) space? statements* `
    case Node of
        [[[],Statement],_Space,[]] when not is_list(Statement) ->
            [Statement];
        [[[],Statement],_Space,[Statements]] when not is_list(Statement) ->
            [Statement|Statements];
        [[[],Statement],_Space,[]] ->
            Statement;
        [[[],Statement],_Space,[Statements]] ->
            Statement ++ Statements
    end
`;

statement_controlflow <- st_if /
                         st_while /
                         st_foreach /
                         st_for /
                         st_switch /
                         st_do_while ~;

statement <- ('@' space?)? (statement_controlflow /
                            st_class /
                            st_function /
                            st_return /
                            st_break /
                            st_continue /
                            st_arith_mono /
                            assign /
                            st_new /
                            st_delete /
                            st_include /
                            st_print /
                            st_die /
                            st_call_function /
                            st_global /
                            st_conditions /
                            st_additive /
                            st_const)
`
    case Node of
        [[],Statement] -> Statement;
        [_,Statement] -> {silent, Statement}
    end
`;

code_parse_error <- !'}' .* `
    throw_error(eparse, Index, Input)
`;

st_conditions <- conditions space? ';' `
    head(Node)
`;

st_additive <- additive space? ';' `
    head(Node)
`;

st_global <- global space var (',' space? var)* space? ';' `
    [_Global,_,Var,Vars|_] = Node,
    GVars = [ Var | [ V || [_,_,V] <- Vars ] ],
    {global, GVars, Index}
`;

st_call_function <- call_function space? ';' `
    head(Node)
`;

include_call <- (include_once / include / require_once / require) space expression `
    [Type,_,Expr|_] = Node,
    #call{name=Type, args=[Expr], line=Index}
`;

st_include <- include_call space? ';' `
    head(Node)
`;

st_new <- new_object space? ';' `
    [New|_] = Node,
    New
`;

st_delete <- delete space (var_complex / var_simple) space? ';' `
    [_Delete,_,Var|_] = Node,
    {delete, Var}
`;

st_print <- (st_print_fun / st_print_old) space? ';' `
    head(Node)
`;

st_print_fun <- (print / echo) space? '(' space? expression space? ')' `
    get_print(nth(5, Node), Index)
`;

st_die <- die space? ';' `
    head(Node)
`;

st_print_old <- (print / echo) space expression `
    get_print(nth(3, Node), Index)
`;

st_arith_mono <- arith_mono space? ';' `
    head(Node)
`;

st_return <- return (space? ( '(' space? )? expression ( space? ')' )?)? space? ';' `
    case Node of
        [_Return,[_,_,Expr|_]|_] -> {return, Expr, Index};
        _ -> {return, undefined, Index}
    end
`;

st_break <- break space? ';' `
    break
`;

st_continue <- continue space? ';' `
    continue
`;

for_assignments <- base_assign ( space? ',' space? base_assign )* `
    [Assign,Assigns] = Node,
    [Assign | [ A || [_,_,_,A] <- Assigns ] ]
`;

st_for <- for space? '(' space? for_assignments space? ';' space? conditions
          space? ';' space? for_assignments space? ')' space?
          ( code_block / code_block_for / statement / ';' / error:(.*) )
`
    [_For,_,_,_,Init,_,_,_,Cond,_,_,_,Update,_,_,_,Code] = Node,
    CodeBlock = case Code of
        {error,Data} -> throw_error(enostatement, Index, Data);
        <<";">> -> undefined;
        _ -> Code
    end,
    #for{init=Init,conditions=Cond,update=Update,loop_block=CodeBlock, line=Index}
`;

switch_case <- ((case space (number / expr_string)) / default) space? ':' space?
               statements
`
    case Node of
    [[_Case,_,Label],_,_,_,St] ->
        #switch_case{label=Label, code_block=St, line=Index};
    [_Default,_,_,_,St] ->
        #switch_case{label=default, code_block=St, line=Index}
    end
`;

st_switch <- switch space? '(' space? expression_cond space? ')' space? '{'
             (space? switch_case space?)+ space? '}'
`
    [_Switch,_,_,_,Cond,_,_,_,_,Cases,_,_] = Node,
    #switch{
        condition=Cond,
        cases=[ Case || [_,Case,_] <- Cases ],
        line=Index}
`;

st_foreach <- foreach space? '(' space? (var / array_def) space as
              (space var space? '=>')?
              space? var space? ')' space?
              ( code_block_foreach / code_block / statement / ';' / error:(.*) )
`
    [_Foreach,_,_,_,List,_,_As,KeyOpt,_,Element,_,_,_,St] = Node,
    case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        <<";">> -> undefined;
        _ -> ok
    end,
    case KeyOpt of
        [] -> #foreach{iter=Element,elements=List,loop_block=St, line=Index};
        [_,Key,_,_] -> #foreach{kiter=Key,
                                iter=Element,
                                elements=List,
                                loop_block=St,
                                line=Index}
    end
`;

st_do_while <- do space? ( code_block / statement / error:(.*) ) space? while
               space? conditions_use space? ';'
`
    [_Do,_,St,_,_While,_,Cond,_,_] = Node,
    case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        _ -> ok
    end,
    #while{type=post, conditions=Cond, loop_block=St, line=Index}
`;

st_while <- while space? conditions_use space? ( code_block_while /
                                                 code_block /
                                                 statement /
                                                 ';' /
                                                 error:(.*) )
`
    [_While,_,Cond,_,St] = Node,
    CodeBlock = case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        <<";">> -> undefined;
        _ -> St
    end,
    #while{type=pre, conditions=Cond, loop_block=CodeBlock, line=Index}
`;

st_if <- st_if_else / st_if_simple ~;

st_if_else <- st_if_simple space? else space?
              ( code_block_if_simple / code_block / statement / error:(.*) ) `
    [#if_block{}=IfBlock,_,_Else,_,ElseSt] = Node,
    case ElseSt of
        {error,Data} -> throw_error(enostatement, Index, Data);
        _ -> ok
    end,
    IfBlock#if_block{false_block=if
        is_list(ElseSt) -> ElseSt;
        true -> [ElseSt]
    end, line=Index}
`;

st_if_simple <- if space? conditions_use space?
                ( code_block_if_simple / code_block_if_else / code_block /
                  statement / error:(.*) ) `
    [_If,_,Cond,_,St] = Node,
    case St of
        {error,Data} -> throw_error(enostatement, Index, Data);
        _ -> ok
    end,
    #if_block{conditions=Cond, true_block=if
        is_list(St) -> St;
        true -> [St]
    end, line=Index}
`;

param <- var (space? '=' space? expression)? `
    case Node of
        [Var,[]] -> Var;
        [Var,[_,_,_,Expression]] -> Var#variable{default_value=Expression}
    end
`;

st_function <- function space key space? '(' space? (param (space? ',' space? param)*
               space?)? ')' space? code_block
`
    case Node of
        [_Func,_,Name,_,_,_,[],_,_,Code] ->
            #function{name=Name, code=Code, line=Index};
        [_Func,_,Name,_,_,_,[Var,Vars,_],_,_,Code] ->
            Args = [Var | [ V || [_,_,_,V] <- Vars ]],
            #function{name=Name, args=Args, code=Code, line=Index}
    end
`;

st_const <- const space key space? '=' space? expression space? ';' `
    [_Const,_,ConstName,_,_,_,Expr|_] = Node,
    #constant{type=define, name=ConstName, value=Expr, line=Index}
`;

%% Assign

composed_assign <- var space? assign_op space? expression `
    [Var,_,Type,_,Expr] = Node,
    #assign{variable=Var, expression = #operation{
        type=Type,
        expression_left=Var,
        expression_right=Expr,
        line=Index}, line=Index}
`;

base_assign <- arith_mono / composed_assign / (var space? '=' space?
               (base_assign / expression))
`
    case Node of
        [Var,_,_Eq,_,Expr] -> #assign{variable=Var, expression=Expr, line=Index};
        MonoArith -> MonoArith
    end
`;

assign <- space? base_assign space? ';' `
    [_,Assign,_,_] = Node,
    Assign
`;

%% Conditions

conditions_use <- '(' space? conditions space? ')' `
    [_,_,Cond,_,_] = Node,
    Cond
`;

conditions <- condition space? nexo space? conditions / cs:condition `
    case Node of
        [A,_,Type,_,B] -> #operation{type=Type,
                                     expression_left=A,
                                     expression_right=B,
                                     line=Index};
        {cs, Param} -> Param
    end
`;

condition <- primary_cond space? comparator space? cs:condition / not space?
             pri:primary_cond / pri:primary_cond
`
    case Node of
        [A,_,Type,_,{cs,B}] ->
            #operation{type=Type, expression_left=A, expression_right=B};
        [_Not,_,{pri, Param}] ->
            {operation_not, Param, Index};
        {pri,Param} ->
            Param
    end
`;

primary_cond <- ("(" space? cs:conditions space? ")") / expression_cond `
    case Node of
        [_,_,{cs,Conditions},_,_] -> Conditions;
        _ -> Node
    end
`;

%% Expressions

expression_cond <- array_def /
                   expr_string /
                   boolean /
                   null /
                   new_object /
                   st_include /
                   st_print_old /
                   st_die /
                   st_print_fun /
                   func_anon /
                   arith_mono /
                   additive /
                   number /
                   call_function /
                   var /
                   constant ~;

expression <- ('@' space?)? (array_def /
                             expr_string /
                             boolean /
                             null /
                             new_object /
                             include_call /
                             func_anon /
                             arith_mono /
                             ternary /
                             conditions /
                             number /
                             call_function /
                             var /
                             constant /
                             additive)
`
    case Node of
        [[],Expression] -> Expression;
        [_,Expression] -> {silent, Expression}
    end
`;

%% Others

ternary <- conditions space? '\?' space? expression (space? ':' space? expression)? `
    case Node of
        [Cond,_,_,_,St,[]] -> #if_block{
            conditions=Cond,
            true_block=St,
            line=Index};
        [Cond,_,_,_,St,[_,_,_,ElseSt]] -> #if_block{
            conditions=Cond,
            true_block=St,
            false_block=ElseSt,
            line=Index}
    end
`;

%% Functions

call_function <- (key '::')? (key / var) space? '(' (space? expression
                 (space? ',' space? expression)*)? space? ')'
`
    {Type,Class} = case hd(Node) of
        [] -> {normal,undefined};
        [ClassName,_] -> {class,ClassName}
    end,
    {FuncName, Arguments} = case Node of
        [_,Name,_,_,[_,Arg,Args],_,_] ->
            {Name, [Arg | [ A || [_,_,_,A] <- Args ]]};
        [_,Name,_,_,[],_,_] ->
            {Name, []}
    end,
    #call{
        type=Type,
        class=Class,
        name=FuncName,
        args=Arguments,
        line=Index}
`;

use_anon <- use space? '(' space? expression (space? ',' space? expression)*
            space? ')' space?
`
    [_Use,_,_Parens,_,Var,Vars|_] = Node,
    [ Var | [ V || [_,_Comma,_,V] <- Vars ]]
`;

func_anon <- function space? '(' space? (var (space? ',' space? var)* space?)?
             ')' space? use_anon? code_block
`
    case Node of
        [_Func,_,_,_,[],_,_,Use,Code] ->
            #function{code=Code, use=Use, line=Index};
        [_Func,_,_,_,[Var,Vars,_],_,_,Use,Code] ->
            Args = [Var | [ V || [_,_,_,V] <- Vars ]],
            #function{code=Code, use=Use, args=Args, line=Index}
    end
`;

%% Objects and Classes

new_object <- new space key (space? '(' (space? expression (space? ',' space?
              expression)*)? space? ')')?
`
    {ObjName, Arguments} = case Node of
        [_New,_,Name,[_,_,[_,Arg,Args],_,_]] ->
            {Name, [Arg | [ A || [_,_,_,A] <- Args ]]};
        [_New,_,Name|_] ->
            {Name, []}
    end,
    #instance{name=ObjName, args=Arguments, line=Index}
`;

% reserved words
if <- #(?i)if# `'if'`;
else <- #(?i)else# `else`;
while <- #(?i)while# `while`;
for <- #(?i)for# `for`;
foreach <- #(?i)foreach# `foreach`;
as <- #(?i)as# `as`;
function <- #(?i)function# `function`;
break <- #(?i)break# `break`;
continue <- #(?i)continue# `continue`;
switch <- #(?i)switch# `switch`;
case <- #(?i)case# `'case'`;
default <- #(?i)default# `default`;
array <- #(?i)array# `array`;
print <- #(?i)print# `print`;
echo <- #(?i)echo# `print`;
do <- #(?i)do# `do`;
and <- #(?i)and# / '&&' `'and'`;
or <- #(?i)or# / '||' `'or'`;
not <- #(?i)not# / '!' `'not'`;
null <- #(?i)null# `undefined`;
true <- #(?i)true# `true`;
false <- #(?i)false# `false`;
return <- #(?i)return# `return`;
global <- #(?i)global# `global`;
include <- #(?i)include# `<<"include">>`;
include_once <- #(?i)include_once# `<<"include_once">>`;
require <- #(?i)require# `<<"require">>`;
require_once <- #(?i)require_once# `<<"require_once">>`;
class <- #(?i)class# `class`;
extends <- #(?i)extends# `extends`;
implements <- #(?i)implements# `implements`;
public <- #(?i)public# `public`;
protected <- #(?i)protected# `protected`;
private <- #(?i)private# `private`;
static <- #(?i)static# `static`;
const <- #(?i)const# `const`;
abstract <- #(?i)abstract# `abstract`;
new <- #(?i)new# `new`;
delete <- #(?i)delete# `delete`;
use <- #(?i)use# `use`;
die <- #(?i)die# `die`;
instanceof <- #(?i)instanceof# `instanceof`;
endfor <- #(?i)endfor# `endfor`;
endif <- #(?i)endif# `endif`;
endwhile <- #(?i)endwhile# `endwhile`;
endforeach <- #(?i)endforeach# `endforeach`;
endswitch <- #(?i)endswitch# `endswitch`;

ends <- else / endforeach / endif / endwhile / endfor / endswitch ~;

mono_logic <- '~' ~;
mono_aritmetic <- '++' / '--' ~;
comparator <- xeq / leq / eq / ne / xne / geq / gt / lt / instanceof ~;

assign_op <- assign_plus / assign_minus / assign_mul / assign_div ~;

assign_plus <- '+=' `<<"+">>`;
assign_minus <- '-=' `<<"-">>`;
assign_mul <- '*=' `<<"*">>`;
assign_div <- '/=' `<<"/">>`;

eq <- '==' ~;
xeq <- '===' ~;

ne <- '!=' / '<>' `<<"!=">>`;
xne <- '!==' / '<=>' `<<"!==">>`;

gt <- '>' ~;
lt <- '<' ~;

geq <- '>=' `<<">=">>`;
leq <- '<=' `<<"=<">>`;

boolean <- true / false ~;

nexo <- and / or ~;

space <- [ \t\n\s\r]+ ~;

% space or comment
sorc <- (space / comment)+ ~;

% definitions

array_index <- arith_mono / ternary / string / additive ~;
array_element <- (array_index space? '=>' space?)? expression `
    case Node of
        [[I|_],Expr] -> #array_element{idx=I, element=Expr, line=Index};
        [[],Expr] -> #array_element{element=Expr, line=Index}
    end
`;

array_def <- array_def_func /
             array_def_func_empty /
             array_def_simple /
             array_def_simple_empty ~;

array_def_simple_empty <- '[' sorc? ']' `
    #array{elements=[], line=Index}
`;

array_def_simple <- '[' sorc? array_element tail:( sorc? ',' sorc?
                    array_element )* ','? sorc? ']'
`
    [_,_,ArrayElement,{tail,Tail}|_] = Node,
    ArrayElements = lists:foldr(fun([_,_,_,NewArrayElement], Elements) ->
        [NewArrayElement|Elements]
    end, [], Tail),
    #array{elements=[ArrayElement|ArrayElements], line=Index}
`;

array_def_func_empty <- array space? '(' space? ')' `
    #array{elements=[], line=Index}
`;

array_def_func <- array space? '(' space? array_element tail:( space? ','
                  space? array_element )* ','? space? ')'
`
    [_Array,_,_,_,ArrayElement,{tail,Tail}|_] = Node,
    ArrayElements = lists:foldr(fun([_,_,_,NewArrayElement], Elements) ->
         [NewArrayElement|Elements]
    end, [], Tail),
    #array{elements=[ArrayElement|ArrayElements], line=Index}
`;

number <- float / integer ~;

float <- '-'? space? [0-9]* '\.' [0-9]+ `
    [Sign,_,Integer,_Dot,Decimal] = Node,
    IntegerBin = iolist_to_binary(Integer),
    DecimalBin = iolist_to_binary(Decimal),
    FloatStr = binary_to_list(<<IntegerBin/binary, ".", DecimalBin/binary>>),
    S = case Sign of
        <<"-">> -> -1;
        _ -> 1
    end,
    #float{float=list_to_float(FloatStr) * S, line=Index}
`;

integer <- '-'? space? [0-9]+ `
    [Sign,_,Int] = Node,
    IntBin = iolist_to_binary(Int),
    IntList = binary_to_list(IntBin),
    S = case Sign of
        <<"-">> -> -1;
        _ -> 1
    end,
    #int{int=list_to_integer(IntList) * S, line=Index}
`;

constant <- (key space? '::')? space? key `
    case Node of
        [[],_,<<"__LINE__">>] ->
            #int{int=ephp_util:get_line(Index), line=Index};
        [[],_,Key] ->
            #constant{name=Key, line=Index};
        [[Class,_,_],_,<<"class">>] ->
            #text{text=Class};
        [[Class,_,_],_,Key] ->
            #constant{type=class, class=Class, name=Key, line=Index}
    end
`;

key <- [a-zA-Z_] [a-zA-Z0-9_]* `
    iolist_to_binary(Node)
`;

var <- var_ref / var_complex / var_simple ~;

var_ref <- '&' space? (var_complex / var_simple) `
    [_,_,Var] = Node,
    #ref{var=Var, line=Index}
`;

var_access <- var_access_array / var_access_object ~;

var_access_object <- '->' space? (call_function / constant / array_index) `
    case Node of
        [<<"->">>,_,#constant{name=Name}] -> {object, Name, Index};
        [<<"->">>,_,Expr] -> {object, Expr, Index}
    end
`;

var_access_array <- '[' space? (array_index space?)? ']' `
    [_,_,I,_] = Node,
    get_index(I)
`;

var_complex <- var_simple space? var_access+ `
    [Var,_,Access] = Node,
    Var#variable{idx=Access, line=Index}
`;

var_simple <- (key '::')? '$' key `
    [RawType,_Dollar, Key] = Node,
    {Type,Class} = case RawType of
        [] -> {normal, undefined};
        [C,_] -> {class, C}
    end,
    #variable{type=Type, class=Class, name=Key, line=Index}
`;

enclosed_var <- enclosed_var_array / enclosed_var_simple ~;

enclosed_var_array <- '$' '{' key ('[' space? (array_index space?)? ']')+ '}' `
    [_Dollar,_,Key,Indexes,_] = Node,
    #variable{name=Key, idx=[ get_index(I) || [_,_,I,_] <- Indexes ], line=Index}
`;

enclosed_var_simple <- '$' '{' key '}' `
    [_Dollar,_,Key,_] = Node,
    #variable{name=Key, line=Index}
`;


%% math operations

arith_params <- array_def /
                new_object /
                func_anon /
                expr_string /
                number /
                boolean /
                null /
                st_print_old /
                st_print_fun /
                call_function /
                var /
                constant /
                logic_mono /
                arith_mono ~;

logic_mono <- mono_logic space? expression `
    [_Op, _, Expr] = Node,
    {operation_bnot, Expr, Index}
`;

arith_mono <- pre:(mono_aritmetic space? var) / post:(var space? mono_aritmetic) `
    case Node of
        {pre, [Type,_,Var]} ->
            case Type of
                <<"++">> -> {pre_incr, Var, Index};
                <<"--">> -> {pre_decr, Var, Index}
            end;
        {post, [Var,_,Type]} ->
            case Type of
                <<"++">> -> {post_incr, Var, Index};
                <<"--">> -> {post_decr, Var, Index}
            end
    end
`;

additive <- multitive space? ( "+" / "-" ) space? additive / mul:multitive `
    case Node of
    [A,_,Type,_,B] ->
        get_op(Type, A, B, Index, Input);
    {mul, Param} -> Param
    end
`;

multitive <- logical space? ( "*" / "/" / "%" ) space? mul:multitive /
             log:logical
`
    case Node of
    [A,_,Type,_,{mul,B}] ->
        get_op(Type, A, B, Index, Input);
    {log, Param} -> Param
    end
`;

logical <- comparative space? ( "^" / "|" / "&" ) space? log:logical /
           comp:comparative
`
    case Node of
        [A,_,Type,_,{log,B}] -> get_op(Type, A, B, Index, Input);
        {comp, Param} -> Param
    end
`;

comparative <- nexitive space? comparator space? comp:comparative /
               not space? nex:nexitive /
               nex:nexitive
`
    case Node of
    [A,_,Comp,_,{comp,B}] ->
        get_op(Comp, A, B, Index, Input);
    [_Not,_,{nex,Param}] ->
        {operation_not, Param, Index};
    {nex,Param} ->
        Param
    end
`;

nexitive <- primary space? nexo space? nex:nexitive /
            not space? pri:primary /
            pri:primary
`
    case Node of
    [A,_,Nexo,_,{nex,B}] ->
        get_op(Nexo, A, B, Index, Input);
    [_Not,_,{pri,Param}] ->
        {operation_not, Param, Index};
    {pri,Param} ->
        Param
    end
`;

primary <- ("(" space? add:additive space? ")") / arith_params `
    case Node of
        [_,_,{add,Additive},_,_] -> Additive;
        _ -> Node
    end
`;

%% strings

expr_string <- concat / string ~;

string <- string_fixed / string_parsed ~;

string_fixed <- "'" (!"'" ("\\\\" / "\\'" / .))* "'" `
    [_,Text,_] = Node,
    #text{text=parse_fixed_string(Text), line=Index}
`;

string_parsed <- '"' (!'"' ("\\\\" / '\\"' / '\\$' / enclosed_var / var / .))* '"' `
    [_,TextRaw,_] = Node,
    {Text,Total} = lists:foldr(fun
        ([[], <<L:1/binary>>], {Text,Total}) ->
            {<<L/binary,Text/binary>>,Total};
        ([[], <<"\\$">>], {Text, Total}) ->
            {<<"$",Text/binary>>, Total};
        ([[], Other], {Text,Total}) ->
            {<<>>, case Text of
                <<>> -> [Other|Total];
                _ -> [Other,parse_string(Text)|Total]
            end}
    end, {<<>>,[]}, TextRaw),
    FinalText = case Text of
        <<>> -> Total;
        _ -> [parse_string(Text)|Total]
    end,
    case FinalText of
        [<<_/binary>>=FT] -> #text{text=FT, line=Index};
        _ -> #text_to_process{text=FinalText, line=Index}
    end
`;

concat_special <- '(' space? (arith_mono / ternary / additive / conditions) space? ')' `
    [_,_,Concat|_] = Node,
    Concat
`;

concat_types <- concat_special /
                boolean /
                null /
                array_def /
                string /
                call_function /
                number /
                var /
                constant ~;

concat <- concat_types (space? '\.' space? concat_types)+ `
    [Str1,Strings] = Node,
    ParsedStrings = [Str1 | [ Str || [_,_,_,Str] <- Strings ]],
    Result = lists:foldr(fun
        (String, []) ->
            [String];
        (#text{text=String}, [#text{text=PrevStr}|RestStr]) ->
            [#text{text = <<String/binary, PrevStr/binary>>}|RestStr];
        (String, RestStr) ->
            [String|RestStr]
    end, [], ParsedStrings),
    case Result of
        [#text{text=Str}=Text] when is_binary(Str) -> Text#text{line=Index};
        _ -> #concat{texts=Result, line=Index}
    end
`;

%% Helpers and other code

`
-include("ephp.hrl").

throw_error(Error, Index, Data) ->
    Output = iolist_to_binary(Data),
    Size = min(byte_size(Output), 20),
    ephp_error:error({error, Error, Index, ?E_PARSE,
        <<Output:Size/binary, "...">>}).

get_print({Type, Value, _}, Index) when
        Type =:= int; Type =:= float; Type =:= text ->
    #print_text{text=ephp_util:to_bin(Value), line=Index};
get_print(Value, Index) when is_atom(Value) ->
    #print_text{text=ephp_util:to_bin(Value), line=Index};
get_print(Expr, Index) ->
    #print{expression=Expr, line=Index}.

get_op(Type, A, B, Index, Data) ->
    case {Type, A, B} of
    {Op, {_,An,_}, {_,Bn,_}} when is_number(An) andalso is_number(Bn) ->
        Result = case Op of
            <<"+">> -> An + Bn;
            <<"-">> -> An - Bn;
            <<"/">> ->
                if
                    Bn == 0 -> throw_error(edivzero, Index, Data);
                    true -> An / Bn
                end;
            <<"*">> -> An * Bn;
            <<"%">> -> trunc(An) rem trunc(Bn);
            <<"^">> -> trunc(An) bxor trunc(Bn);
            <<"|">> -> trunc(An) bor trunc(Bn);
            <<"&">> -> trunc(An) band trunc(Bn);
            _ -> undefined
        end,
        if
            is_integer(Result) ->
                #int{int=Result, line=Index};
            is_float(Result) ->
                #float{float=Result, line=Index};
            true ->
                #operation{type=Type, expression_left=A,
                    expression_right=B, line=Index}
        end;
    _ ->
        #operation{type=Type, expression_left=A, expression_right=B,
            line=Index}
    end.

parse_string(Text) ->
    parse_string(iolist_to_binary(Text), <<>>).

parse_string(<<>>, Result) ->
    Result;
parse_string(<<"\\\\",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\\>>);
parse_string(<<"\\n",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\n>>);
parse_string(<<"\\t",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\t>>);
parse_string(<<"\\r",Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, $\r>>);
parse_string(<<C:1/binary,Rest/binary>>, Result) ->
    parse_string(Rest, <<Result/binary, C/binary>>).

parse_fixed_string(Text) ->
    parse_fixed_string(iolist_to_binary(Text), <<>>).

parse_fixed_string(<<>>, Result) ->
    Result;
parse_fixed_string(<<"\\\\",Rest/binary>>, Result) ->
    parse_fixed_string(Rest, <<Result/binary, $\\>>);
parse_fixed_string(<<"\\n",Rest/binary>>, Result) ->
    parse_fixed_string(Rest, <<Result/binary, $\\, $n>>);
parse_fixed_string(<<"\\t",Rest/binary>>, Result) ->
    parse_fixed_string(Rest, <<Result/binary, $\\, $t>>);
parse_fixed_string(<<"\\r",Rest/binary>>, Result) ->
    parse_fixed_string(Rest, <<Result/binary, $\\, $r>>);
parse_fixed_string(<<C:1/binary,Rest/binary>>, Result) ->
    parse_fixed_string(Rest, <<Result/binary, C/binary>>).

nth(N, [A|_]) when N =< 1 -> A;
nth(_, []) -> undefined;
nth(N, [_|List]) -> nth(N-1, List).

head([H|_]) -> H.

get_index([I,_]) -> I;
get_index([]) -> auto.

`
